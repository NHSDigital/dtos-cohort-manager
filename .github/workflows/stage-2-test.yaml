name: Test stage

on:
  workflow_call:
    inputs:
      unit_test_dir:
        description: Directory containing the unit tests
        required: true
        type: string
      unit_test_logger_format:
        description: Test report format
        required: false
        default: trx
        type: string
      build_datetime:
        description: Build datetime, set by the CI/CD pipeline workflow
        required: true
        type: string
      build_timestamp:
        description: Build timestamp, set by the CI/CD pipeline workflow
        required: true
        type: string
      build_epoch:
        description: Build epoch, set by the CI/CD pipeline workflow
        required: true
        type: string
      nodejs_version:
        description: Node.js version, set by the CI/CD pipeline workflow
        required: true
        type: string
      python_version:
        description: Python version, set by the CI/CD pipeline workflow
        required: true
        type: string
      terraform_version:
        description: Terraform version, set by the CI/CD pipeline workflow
        required: true
        type: string
      version:
        description: Version of the software, set by the CI/CD pipeline workflow
        required: true
        type: string

jobs:
  check-consolidated-tests:
    name: Check for consolidated test project
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      has-consolidated-tests: ${{ steps.check.outputs.has-consolidated-tests }}
    env:
      UNIT_TEST_DIR: ${{ inputs.unit_test_dir }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true
      - name: Check for ConsolidatedTests.csproj
        id: check
        run: |
          if [ -f "${UNIT_TEST_DIR}/ConsolidatedTests.csproj" ]; then
            echo "Found ConsolidatedTests.csproj in root directory"
            echo "has-consolidated-tests=true" >> "${GITHUB_OUTPUT}"
          else
            echo "No ConsolidatedTests.csproj found in root directory"
            echo "has-consolidated-tests=false" >> "${GITHUB_OUTPUT}"
          fi

  unit-test-scope:
    name: Get unit test scopes
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [check-consolidated-tests]
    if: needs.check-consolidated-tests.outputs.has-consolidated-tests == 'false'
    outputs:
      test-matrix: ${{ steps.matrix.outputs.test-matrix }}
    env:
      UNIT_TEST_DIR: ${{ inputs.unit_test_dir }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true
      - name: Create matrix for parallel jobs
        id: matrix
        run: |
          set -eo pipefail
          mapfile -t test_matrix < <(find "${UNIT_TEST_DIR}" -mindepth 1 -maxdepth 1 -type d | sed 's|.*/||')
          test_matrix_json=$(jq -c -n '$ARGS.positional' --args "${test_matrix[@]}")
          echo "Unit test scopes: ${test_matrix_json}"
          echo "test-matrix=${test_matrix_json}" >> "${GITHUB_OUTPUT}"

  test-consolidated:
    name: Run consolidated tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [check-consolidated-tests]
    if: needs.check-consolidated-tests.outputs.has-consolidated-tests == 'true'
    env:
      UNIT_TEST_DIR: ${{ inputs.unit_test_dir }}
      LOGGER_FORMAT: ${{ inputs.unit_test_logger_format }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true
      - name: Run consolidated test suite
        continue-on-error: true
        run: |
          set -eo pipefail
          mkdir "TestResults"
          echo -e "\nRunning consolidated tests from:\n${UNIT_TEST_DIR}/ConsolidatedTests.csproj"
          dotnet test "${UNIT_TEST_DIR}/ConsolidatedTests.csproj" --results-directory "TestResults" --logger "${LOGGER_FORMAT};LogFileName=ConsolidatedTests.${LOGGER_FORMAT}" --collect:"XPlat Code Coverage" --verbosity quiet
      - name: Upload test results as artifact
        uses: actions/upload-artifact@v4
        with:
          name: test-results-consolidated
          path: |
            TestResults/**/*.${{ inputs.unit_test_logger_format }}
            TestResults/**/coverage.cobertura.xml

  test-unit:
    name: Unit tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [unit-test-scope, check-consolidated-tests]
    strategy:
      matrix:
        scope: ${{ fromJSON(needs.unit-test-scope.outputs.test-matrix) }}
    if: needs.check-consolidated-tests.outputs.has-consolidated-tests == 'false' && needs.unit-test-scope.outputs.test-matrix != '[]'
    env:
      UNIT_TEST_DIR: ${{ inputs.unit_test_dir }}
      LOGGER_FORMAT: ${{ inputs.unit_test_logger_format }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true
      - name: Run unit test suite
        continue-on-error: true
        run: |
          set -eo pipefail
          mkdir "TestResults"
          find "${UNIT_TEST_DIR}/${{ matrix.scope }}" -name '*.csproj' | while read -r file; do
            echo -e "\nRunning unit tests for:\n${file}"
            base=$(basename "$file" .csproj)
            dotnet test "${file}" --results-directory "TestResults" --logger "${LOGGER_FORMAT};LogFileName=${base}.${LOGGER_FORMAT}" --collect:"XPlat Code Coverage" --verbosity quiet
          done
      - name: Upload test results as artifact
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.scope }}
          path: |
            TestResults/**/*.${{ inputs.unit_test_logger_format }}
            TestResults/**/coverage.cobertura.xml

  aggregate-test-results:
    name: Aggregate results and report
    runs-on: ubuntu-latest
    needs: [test-unit, test-consolidated, check-consolidated-tests]
    if: always() && (needs.check-consolidated-tests.outputs.has-consolidated-tests == 'true' || needs.unit-test-scope.outputs.test-matrix != '[]')
    permissions:
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true
      - name: Download all test results
        uses: actions/download-artifact@v4
        with:
          path: aggregated-results
      - name: Process coverage reports
        continue-on-error: true
        run: |
          mkdir coverage
          if [[ "${{ needs.check-consolidated-tests.outputs.has-consolidated-tests }}" == "true" ]]; then
            echo "Using consolidated test coverage report"
            # Find the consolidated coverage report and copy it directly
            find aggregated-results -name "coverage.cobertura.xml" -exec cp {} coverage/cobertura.xml \;
            cp coverage/cobertura.xml coverage/vscoverage.xml
          else
            echo "Collating multiple coverage reports"
            dotnet tool install --global dotnet-coverage
            dotnet coverage merge *.cobertura.xml --recursive -o coverage/vscoverage.xml -f xml
            dotnet coverage merge *.cobertura.xml --recursive -o coverage/cobertura.xml -f cobertura
          fi
      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: test-coverage-report
          path: coverage/*.xml
      - name: Report results
        uses: bibipkins/dotnet-test-reporter@v1.5.3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          comment-title: Unit Test Results
          results-path: aggregated-results/**/*.${{ inputs.unit_test_logger_format }}
          coverage-type: cobertura
          coverage-path: coverage/cobertura.xml
          # coverage-threshold: 50

  test-lint:
    name: Linting
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Run linting
        run: |
          make test-lint
      - name: Save the linting result
        run: |
          echo "Nothing to save"

  perform-static-analysis:
    name: Perform static analysis
    needs: [aggregate-test-results]
    if: always() && needs.aggregate-test-results.result != 'skipped'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0 # Full history is needed to improving relevancy of reporting
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: "zulu"
      - name: Install .NET SDKs
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            7.0.x
            8.0.x
            9.0.x
      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: test-coverage-report
          path: coverage
      - name: Cache SonarQube Cloud packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar
      - name: Cache SonarQube Cloud scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: ./.sonar/scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner
      - name: Install SonarQube Cloud scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        run: |
          mkdir -p .sonar/scanner
          dotnet tool install dotnet-sonarscanner --tool-path ./.sonar/scanner
      - name: Build and analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          echo "Starting SonarCloud analysis with:"
          echo "Project key: ${{ vars.SONAR_PROJECT_KEY }}"
          echo "Organization key: ${{ vars.SONAR_ORGANISATION_KEY }}"
          
          # Begin SonarScanner
          ./.sonar/scanner/dotnet-sonarscanner begin \
            /k:"${{ vars.SONAR_PROJECT_KEY }}" \
            /o:"${{ vars.SONAR_ORGANISATION_KEY }}" \
            /d:sonar.token="${{ secrets.SONAR_TOKEN }}" \
            /d:sonar.host.url="https://sonarcloud.io" \
            /d:sonar.cs.vscoveragexml.reportsPaths="coverage/vscoverage.xml" \
            /d:sonar.cs.opencover.reportsPaths="coverage/cobertura.xml"
          
          # Build the solution without running tests
          find . -name "*.sln" | xargs -I {} dotnet build {} --no-restore
          
          # End SonarScanner
          ./.sonar/scanner/dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"