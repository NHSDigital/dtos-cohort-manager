parameters:
  - name: hostPoolName
    type: string
  - name: serviceConnection
    type: string
  - name: targetSubscriptionId
    type: string
  - name: terraformActions
    type: string
  - name: tfVarsFile
    type: string
  - name: environment
    type: string
  - name: resourceGroupNameSql
    type: string
  - name: databaseManagementJobName
    type: string
  - name: dockerImageTag
    type: string
  - name: retagImages
    type: boolean
  - name: retagImagesFrom
    type: string
  - name: retagImagesTo
    type: string
  - name: slackWebHook
    type: string
    default: ''

stages:
- stage: retag_images_stage
  # Only required until commit hashes are passed in by calling pipeline, except for the
  # PreProd pipeline which needs to retag images to move them from the Dev ACR to the Prod ACR
  displayName: ACR re-tag
  pool:
    name: ${{ parameters.hostPoolName }}
  jobs:
    - job: re_tag
      displayName: Re-tag Docker images
      condition: in('${{ parameters.retagImages }}', 'true')
      variables:
        SELECT_IMAGE_TAG: ${{ parameters.retagImagesFrom }}
        ADD_IMAGE_TAG: ${{ parameters.retagImagesTo }}
      steps:
        - template: .azuredevops/templates/steps/acr-import-retag-no-additional-tags.yaml@dtos-devops-templates
          parameters:
            serviceConnection: ${{ parameters.serviceConnection }}

- stage: terraform_deploy_stage
  ${{ if eq(parameters.terraformActions, 'Apply') }}:
    displayName: Terraform Deploy
  ${{ else }}:
    displayName: Terraform Plan Only
  condition: in(dependencies.retag_images_stage.result, 'Succeeded', 'Skipped')
  variables:
    tfVarsFile: ${{ parameters.tfVarsFile }}
  pool:
    name: ${{ parameters.hostPoolName }}
  jobs:
    - job: init_and_plan
      displayName: Init, plan, store artifact
      steps:
        - checkout: self
        - checkout: dtos-devops-templates
        - template: .azuredevops/templates/steps/tf_plan.yaml@dtos-devops-templates
          parameters:
            tfCommandOptions: '-var="docker_image_tag=${{ parameters.dockerImageTag }}"'

    - deployment: terraform_apply
      displayName: Init, get plan artifact, apply
      environment: ${{ parameters.environment }}
      dependsOn: init_and_plan
      condition: |
        and(
          eq(dependencies.init_and_plan.outputs['TerraformPlan.changesPresent'], 'true'), 
          eq('${{ parameters.terraformActions }}', 'Apply')
        )
      strategy:
        runOnce:
          deploy:
            steps:
              - checkout: self
              - checkout: dtos-devops-templates
              - template: .azuredevops/templates/steps/tf_apply.yaml@dtos-devops-templates

- stage: db_changes_stage
  displayName: Database changes
  dependsOn: terraform_deploy_stage
  condition: in(dependencies.terraform_deploy_stage.result, 'Succeeded', 'Skipped')
  pool:
    name: ${{ parameters.hostPoolName }}
  jobs:
    - job: db_changes
      displayName: Apply database changes
      steps:
        - checkout: self
        - checkout: dtos-devops-templates
        - template: .azuredevops/templates/steps/app-container-job-start.yaml@dtos-devops-templates
          parameters:
            serviceConnection: ${{ parameters.serviceConnection }}
            targetSubscriptionId: ${{ parameters.targetSubscriptionId }}
            resourceGroupName: ${{ parameters.resourceGroupNameSql }}
            jobName: ${{ parameters.databaseManagementJobName }}

- stage: restart_functions_stage
  displayName: Restart Function Apps
  dependsOn:
  - terraform_deploy_stage
  - db_changes_stage
  condition: |
    or(
      in(dependencies.terraform_deploy_stage.result, 'Succeeded', 'Skipped'),
      in(dependencies.db_changes_stage.result, 'Succeeded', 'Skipped')
    )
  pool:
    name: ${{ parameters.hostPoolName }}
  jobs:
    - job: restart_functions
      displayName: Restart Function Apps to load new images
      steps:
        - template: .azuredevops/templates/steps/app-services-restart.yaml@dtos-devops-templates
          parameters:
            serviceConnection: ${{ parameters.serviceConnection }}

- stage: notify_stage
  displayName: Send Slack Notification
  condition: |
    and(
      always(),
      eq(variables['Build.SourceBranch'], 'refs/heads/feat/dtoss-10921-slack-generic-messaging'),
      ne('${{ parameters.slackWebHook }}', '')
    )
  pool:
    name: ${{ parameters.hostPoolName }}
  jobs:
    - job: notify
      displayName: Send Slack Notification
      variables:
        slackSuccessMessage: |
          ✅ The infrastructure deployment for the ${{ parameters.environment }} environment has completed for user: $(Build.RequestedFor).
          ⚙️ Please check the ADO pipeline results for details: $(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)
          📊 NOTE: End to End tests may still be running: please check #cohort-manager-tests for completed test results.
          ⚙️ Please check GitHub for any subsequent workflows that need approving: https://github.com/NHSDigital/dtos-cohort-manager/actions?query=branch%3Amain

        slackFailureMessage: |
          ❌ The infrastructure deployment for the ${{ parameters.environment }} environment has failed for user: $(Build.RequestedFor).
          ⚙️ Please check the ADO pipeline results for details: $(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)

      steps:
        - checkout: dtos-devops-templates
          sparseCheckoutDirectories: scripts
          path: templates
          displayName: 'Checkout Templates Repo'

        - task: PythonScript@0
          name: slack_success
          displayName: Send Slack Notification (Success)
          condition: succeeded()
          inputs:
            scriptSource: 'filePath'
            scriptPath: '$(Pipeline.Workspace)/templates/scripts/integrations/slack/SlackIntegrator.py'
            arguments: >
              --webhook "${{ parameters.slackWebHook }}"
              --message "$(slackSuccessMessage)"

        - task: PythonScript@0
          name: slack_failure
          displayName: Send Slack Notification (Failure)
          condition: failed()
          inputs:
            scriptSource: 'filePath'
            scriptPath: '$(Pipeline.Workspace)/templates/scripts/integrations/slack/SlackIntegrator.py'
            arguments: >
              --webhook "${{ parameters.slackWebHook }}"
              --message "$(slackFailureMessage)"
