---

name: $(Build.SourceBranchName)-$(Date:yyyyMMdd)_$(Rev:r)
trigger: none
pr: none

pool:
  name: private-pool-dev-uks

resources:
  repositories:
    - repository: dtos-devops-templates
      type: github
      name: NHSDigital/dtos-devops-templates
      ref: feat/DTOSS-7048-deploy-temp-environments-post-7360
      endpoint: NHSDigital

variables:
  - group: TEMP_ENVIRONMENTS_core_backend
  - group: TEMP_ENVIRONMENTS_audit_backend_remote_state
  - group: DEV_hub_backend_remote_state
  - name: TF_DIRECTORY
    value: $(System.DefaultWorkingDirectory)/$(System.TeamProject)/infrastructure/tf-core
  - name: TF_VERSION
    value: 1.9.2

parameters:
  - name: pipelineAction
    displayName: 'Pipeline Action'
    type: string
    values:
      - 'Apply'
      - 'Destroy'
    default: 'Apply'

stages:
  - stage: terraform_setup
    displayName: Terraform Setup
    jobs:
      - job: set_variables
        displayName: Set Terraform Variables
        steps:
          - task: AzureCLI@2
            name: set_variables
            displayName: Set Terraform Variables
            inputs:
              azureSubscription: $(SERVICE_CONNECTION)
              scriptLocation: inlineScript
              scriptType: bash
              workingDirectory: $(tfExecutionDir)
              inlineScript: |
                task_number=$(echo $(Build.SourceBranchName) | cut -d'/' -f2 | awk -F'-' '{print $2}')
                temp_environment_name="temp${task_number}"
                storage_container_name="temp-environment-${task_number}-core"
                storage_container_name_audit="temp-environment-${task_number}-audit"
                tf_plan_artefact_path="tf_plan_core_${temp_environment_name}"
                # Output the values for debugging:
                echo "##[debug] task_number: $task_number"
                echo "##[debug] temp_environment_name: $temp_environment_name"
                echo "##[debug] storage_container_name: $storage_container_name"
                echo "##[debug] storage_container_name_audit: $storage_container_name_audit"
                echo "##[debug] tf_plan_artefact_path: $tf_plan_artefact_path"
                # Set the output variables
                echo "##vso[task.setvariable variable=task_number;isOutput=true]$task_number"
                echo "##vso[task.setvariable variable=temp_environment_name;isOutput=true]$temp_environment_name"
                echo "##vso[task.setvariable variable=storage_container_name;isOutput=true]$storage_container_name"
                echo "##vso[task.setvariable variable=storage_container_name_audit;isOutput=true]$storage_container_name_audit"
                echo "##vso[task.setvariable variable=tf_plan_artefact_path;isOutput=true]$tf_plan_artefact_path"
      - job: configure_backend
        displayName: Configure Backend
        dependsOn: set_variables
        variables:
          temp_environment_name: $[ dependencies.set_variables.outputs['set_variables.temp_environment_name'] ]
          storage_container_name: $[ dependencies.set_variables.outputs['set_variables.storage_container_name'] ]
        steps:
          - task: AzureCLI@2
            displayName: Configure Backend
            inputs:
              azureSubscription: $(SERVICE_CONNECTION)
              scriptLocation: inlineScript
              scriptType: bash
              workingDirectory: $(tfExecutionDir)
              inlineScript: |
                # Check if the backend configuration file exists and if not, create the container for it:
                container_exists=$(az storage container exists --name $(storage_container_name) --account-name $(BACKEND_AZURE_STORAGE_ACCOUNT_NAME) --auth-mode login --output tsv)
                if [ "$container_exists" == "True" ]; then
                  echo "##[debug] Container $(storage_container_name) already exists"
                else
                  echo "##[debug] Container $(storage_container_name) does not exist, creating it..."
                  az storage container create --name $(storage_container_name) --account-name $(BACKEND_AZURE_STORAGE_ACCOUNT_NAME) --resource-group $(BACKEND_AZURE_RESOURCE_GROUP_NAME) --auth-mode login
                fi

                # Check if the SQL Server admin group exists and if not, create it:
                # Temporary workaround as we cannot create groups via the pipeline:
                # sql_server_admin_group_name="sqlsvr_cohman_$(temp_environment_name)_uks_admin"
                sql_server_admin_group_name="sqlsvr_cohman_temp_uks_admin"
                sql_server_admin_group_exists=$(az ad group show --group ${sql_server_admin_group_name} --output tsv)
                # CHANGE the following as the "show" command will return an error if the group does not exist, so the comparison string is never empty:
                if [ "$sql_server_admin_group_exists" == "" ]; then
                  echo "##[debug] SQL Server admin group ${sql_server_admin_group_name} does not exist, creating it..."
                  az ad group create --display-name ${sql_server_admin_group_name} --mail-nickname ${sql_server_admin_group_name}

                  # Add the PL managed identity to the SQL Server admin group:
                  miName='MI-COHORT-MANAGER-DEV-UKS'
                  resourceGroupMi='rg-mi-dev-uks'
                  managedIdentity=$(az identity show --name $miName --resource-group $resourceGroupMi --subscription $subscriptionIdHub)
                  managedIdentityId=$(echo $managedIdentity | jq -r '.principalId')
                  az ad group member add --group ${sql_server_admin_group_name} --member-id $managedIdentityId
                else
                  echo "##[debug] SQL Server admin group ${sql_server_admin_group_name} already exists"
                fi

  - stage: terraform_plan
    displayName: Terraform Plan
    dependsOn: [terraform_setup]
    condition: and(eq('${{ parameters.pipelineAction }}', 'Apply'), eq(variables['Build.Reason'], 'Manual'))
    variables:
      TF_PLAN_ARTIFACT: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.tf_plan_artefact_path'] ]
      ENVIRONMENT: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.temp_environment_name'] ]
      BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.storage_container_name'] ]
      AUDIT_BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.storage_container_name_audit'] ]
      tfCommandOptions: >-
        -var=environment=$(ENVIRONMENT)
        -var=AUDIT_BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME=$(AUDIT_BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME)
      tfVarsFile: environments/temporary-environments.tfvars
    jobs:
      - job: init_and_plan
        displayName: Init, plan, store artifact
        steps:
          - checkout: self
          - checkout: dtos-devops-templates
          - template: .azuredevops/templates/steps/tf_plan.yaml@dtos-devops-templates

  - stage: terraform_apply
    displayName: Terraform Apply
    dependsOn: [terraform_setup, terraform_plan]
    condition: and(eq('${{ parameters.pipelineAction }}', 'Apply'), eq(dependencies.terraform_plan.outputs['init_and_plan.TerraformPlan.changesPresent'], 'true'), eq(variables['Build.Reason'], 'Manual'))
    variables:
      TF_PLAN_ARTIFACT: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.tf_plan_artefact_path'] ]
      ENVIRONMENT: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.temp_environment_name'] ]
      BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.storage_container_name'] ]
      AUDIT_BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.storage_container_name_audit'] ]
    jobs:
      - deployment: terraform_apply
        displayName: Init, get plan artifact, apply
        environment: temporary-environments
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                - checkout: dtos-devops-templates
                - template: .azuredevops/templates/steps/tf_apply.yaml@dtos-devops-templates


  - stage: terraform_destroy
    displayName: Terraform Destroy
    dependsOn: [terraform_setup]
    condition: and(eq('${{ parameters.pipelineAction }}', 'Destroy'), eq(variables['Build.Reason'], 'Manual'))
    variables:
      TF_PLAN_ARTIFACT: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.tf_plan_artefact_path'] ]
      ENVIRONMENT: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.temp_environment_name'] ]
      BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.storage_container_name'] ]
      AUDIT_BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME: $[ stageDependencies.terraform_setup.set_variables.outputs['set_variables.storage_container_name_audit'] ]
      tfCommandOptions: >-
        -var=environment=$(ENVIRONMENT)
        -var=AUDIT_BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME=$(AUDIT_BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME)
      tfVarsFile: environments/temporary-environments.tfvars
    jobs:
      - deployment: terraform_destroy
        displayName: Init, get plan artifact, destroy
        environment: temporary-environments
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                - checkout: dtos-devops-templates
                - template: .azuredevops/templates/steps/tf_destroy.yaml@dtos-devops-templates

  # Remember to clean up other resources such as the state file and SQL Server admin group
